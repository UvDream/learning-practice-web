# 类型推断

> 在没有明确指出类型的地方,类型推断会帮助提供类型

## 示例 1

```typescript
let x = 3;
x = "3"; //Error:不能将类型“string”分配给类型“number”。
```

这里 x 被推断为 number,所以再次赋值为 string 是错误的

> 类型推断是从有向左推断的

## 示例 2

> 定义初始类型以及部分成员初始值

```typescript
interface Foo {
  bar: number;
}
let foo = <Foo>{};
foo.bar = 1;
```

## 示例 3

> 定义初始值

```typescript
interface Foo {
  bar: number;
}
let foo: Foo = {
  bar: 1,
};
```

## 示例 4:类型断言

```typescript
interface Foo {
  bar: number;
}
let foo = {} as Foo; //类型断言
foo.bar = 1;
```

# 类型兼容

> 当一个类型 Y 可以被赋值给另一个类型 X 时，我们就可以说类型 X 兼容类型 Y ---------X 兼容 Y：X（目标类型）= Y（源类型）

## 简单示例

```typescript
let a = {
  age: 1,
  name: "张三",
};
let b = {
  age: 1,
};
b = a;
a = b; //Error
```

## 接口兼容性

```typescript
interface X {
  a: any;
  b: any;
}
interface Y {
  a: any;
  b: any;
  c: any;
}
let x: X = { a: 1, b: 2 };
let y: Y = { a: 1, b: 2, c: 3 };
x = y;
y = x; //Error
```

> 接口之间的兼容时候，`成员少的兼容成员多的`

## 函数兼容性

### 参数个数

```typescript
type Handler = (a: number, b: number) => void;
function hof(handler: Handler) {
  return handler;
}
let handler1 = (a: number) => {};
hof(handler1);
let handler2 = (a: number, b: number, c: number) => {};
hof(handler2); //Error
```

> 函数兼容性参数多的可以兼容少的

### 可选参数和剩余参数

```typescript
let a = (p1: number, p2: number) => {};
let b = (p1?: number, p2?: number) => {};
let c = (...args: number[]) => {};
a = b;
a = c;
b = a; //Error
b = c; //Error
c = a;
c = b;
```

> 固定参数兼容可选参数和剩余参数，可选参数不能兼容固定参数和剩余参数，剩余参数可以兼容固定参数和可选参数

### 参数类型

```typescript
type Handler = (a: number, b: number) => void;
function hof(handler: Handler) {
  return handler;
}
let handler3 = (a: string) => {};
hof(handler3); //Error

interface Point3D {
  x: number;
  y: number;
  z: number;
}
interface Point2D {
  x: number;
  y: number;
}
let p3d = (point: Point3D) => {};
let p2d = (point: Point2D) => {};
p3d = p2d;
p2d = p23; //Error
```

> 函数兼容性遵循`多的可以兼容少`的,也就是函数参数只能少传,不能多传.与接口之间兼容性相反

### 函数返回值

```typescript
let f = () => ({ name: "Alice" });
let g = () => ({ name: "Alice", location: "Beijing" });
f = g;
g = f; //Error
```
> `少的可以兼容多的`
### 函数重载
```typescript

```